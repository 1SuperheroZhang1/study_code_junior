package array_exer;
/* 排序算法
 * 排序:假设含有n个记录的序列为(R1,R2,...,Rn),其相应的关键字序列为{K1,K2,...,Kn}.
 *      将这些记录重新排序为(Ri1,Ri2,...,Rin),使得相应的关键字值满足条件Ki1<=Ki2<=...<=Kin,这样的一种操作称为排序。
 *  >通常来说，排序的目的是快速查找。
 *  衡量排序算法的优劣:
 *  1.时间复杂度:分析关键字的比较次数和记录的移动次数
 *  2.空间复杂度:分析排序算法中需要多少辅助内存。
 *  3.稳定性:若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种排序算法是稳定的。
 * */
/* 排序算法分类:内部排序和外部排序
 * >内部排序:整个排序过程不需要借助于外部存储器(如磁盘等)，所有排序操作都在内存中完成。
 * >外部排序:参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助于外部存储设备(如磁盘)，外部排序最常见的是归并排序，可以认为外部排序是由多次内部排序组成。 
 * */
/* 十大内部排序算法
 *  选择排序
 *  	>直接选择排序、堆排序
 *  交换排序
 *  	>冒泡排序、快速排序
 *  插入排序
 *  	>直接插入排序、折半插入排序、Shell排序
 *  归并排序
 *  桶式排序
 *  基数排序
 * 
 * */
/* 算法的五大特征
 * 1.输入
 * 2.输出
 * 3.有穷性
 * 4.确定性
 * 5.可行性
 * */
/*
 * 数组的冒泡排序
 * */
public class ArrayAlg3_BubbleSort {
	public static void main(String[] args) {
		int[] arr= new int[]{1,4,6,8,6,4,3,2,-1};
		//冒泡排序
		for(int i=0;i<arr.length-1;i++) {
			for(int j=0;j<arr.length-1-i;j++) {
				if(arr[j]>arr[j+1]) {
					int tmp=arr[j];
					arr[j]=arr[j+1];
					arr[j+1]=tmp;
				}
			
			}
		}
		for(int i=0;i<arr.length;i++) {
			System.out.print(arr[i]+" ");
		}
	}

}
